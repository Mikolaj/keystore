{"name":"Keystore","tagline":"storing secret things","body":"keystore: storing secret things\r\n===============================\r\n\r\nWriting deployment scripts is a critical yet error-prone activity which we\r\nwould rather do in Haskell. One of the most difficult aspect of deployment\r\nscripts is the management of credentials: they cannot be stored in the\r\nVCS like almost everything else, but need to be organised and accessed\r\nwhile under lock and key. This is the problem that keystore is trying to solve:\r\nflexible, secure and well-typed deployment scripts.\r\n\r\n  * This module is written purely in Hakell and all of the cryptographic packages\r\n    it relies upon are written in Haskell.\r\n\r\n  * It stores everything in a JSON format that has proven to be stable. We can can\r\n    use [migrations](http://hackage.haskell.org/package/api-tools) > in future\r\n    should the store need to be reorganized.\r\n\r\n  * The underlying model is simple and flexible:\r\n\r\n      + *Named keys*: every key has an name within the store that is associated\r\n        with some secret data. If the secret data for that key is to be stored then\r\n        it must identify another key in the store that will be used to encrypt the\r\n        data. (Some keys -- the passwords -- will typically be auto-loaded from\r\n        environment variables.)\r\n      + *Functional model*: keys can be deleted and added again but the design\r\n        encourages the retention of the history. The old keys remain available\r\n        but deployment scripts will naturally select the latest version of a key.\r\n        When a key is rotated this merely loads a new generation for the rotated\r\n        key.\r\n      + *Simple metadata*: oher information, such as the identity of the key\r\n        with its originating system (e.g., the identifier of an AWS IAM key)\r\n        and some arbitrary textual information (the 'comment') may be associated\r\n        with a key and accessible without recourse to the key or password needed\r\n        to access the secret information.\r\n      + *PKS*: the seret may be a RSA provate key with the public key stored\r\n        separately in the cler.\r\n      + *MFA*: a secret may be protected with multiple named keys, all of which\r\n        will be needed to recover the secret text.\r\n      + *Hashing*: all keys can be hashed with an appropriate PBKDF-2 function\r\n        and the hashes stored in the clear. These hashes may be sued to verify\r\n        passwords but also can be inserted directly into configuration files\r\n        for deployment. Precise control of the PBKDF-2 hash paramers is\r\n        avaiable.\r\n      + *Hierarchical organization*: keys can be stored in different sections\r\n        with each key being protected by a master key for that section. Sections\r\n        can be configured to store the master keys of other sections thereby\r\n        gaining acces to all of the keys in those sections and the keys they\r\n        have access to.\r\n      + *Systems integratio*: keys can automatically loaded from Environment\r\n        variables. Typically a keystore session will start by settingb up an\r\n        environment variable for the deployment section corresponding for\r\n        the node that you need to deploy to. This will provide access to\r\n        precisely the keys whose secrets you need to carry out the deployment\r\n        and no more. It only needs access to the hashes of admin keys then they\r\n        can be placed in separate higher-level `admin` sections. Provided care\r\n        is taken preparing the environment you will not deploy to the wrong host\r\n        (e.g., a live server rather than a staging server, or the wrong live\r\n        server) because those keys will not be accessible.\r\n      + *Configuration control*: the parameters controling the encryption and\r\n        hashing functions can be set up independently in each section of the\r\n        store, allowing for heavier hashing to be used on live servers and\r\n        light hashing to be used on development and staging servers where\r\n        authentication needs to be quick.\r\n      + *Keystore integrity*: the keystore can be signed and every operation\r\n        made to check that the keystore matches its signature (and the public\r\n        signing key matches an independent copy on the client).\r\n      + *External crypto operations*: keys in the keystore can be used to sign\r\n        or encrypt external obejcts (provided they can be loaded into memory).\r\n\r\n  * Perhaps apropriately, the keystore package has several layers. Most users\r\n    will probably need only the top \"batteries-included\" layer:\r\n\r\n      + `Data.KeyStore.Sections`: this provides a high-level model that allows\r\n        a flexible hierarchical keystore to be set up relatively easily.\r\n        See the 'deploy' examplefor details.\r\n      + `Data.KeyStore.CLI` : This provides a stanalone program for inspecting\r\n        and editing your keystores. It can also be embedded into your own\r\n        deployment app. See the `deploy` example for details.\r\n      + `Data.KeyStore.IO`: this library provides general programatic access to\r\n        a keystore through `IO` primitives. See the source code for the `Sections`\r\n        for an example of this module in use.\r\n      + `Data.KeyStore.KS`: this library provides general programatic access to\r\n        a keystore through functional `KS` primitives. See the source code for\r\n        the `IO` for an exteded example this system in action.\r\n      + `Data.KeyStore.Types`: This provides access to keystores at the types\r\n        level.\r\n\r\n\r\n0.5 Migration instructions\r\n--------------------------\r\n\r\nThe formation of the names used in 'Data.Keystore.Sections' derived keystores\r\nhas changed to fix an issue (#3) that barred hosts, sections and key identifiers\r\nfrom being prefixes of each other. See the changelog for details, especially\r\non how to ensure that an existing Sections-based keystore gets migrated properly.\r\n\r\n\r\nLaunch Instructions\r\n-------------------\r\n\r\nSet yourself up with a ghc-7.6.3 or ghc-7.8.3 environment as appropriate.\r\n````bash\r\ncabal install keystore\r\n````\r\nIn addition to the keystore package library, this will establish in you cabal\r\nbin directory the `ks` and `deploy` binaries. `ks` is the generic programme\r\nfor inspecting and editing keystores.\r\n````bash\r\nks --help\r\n````\r\nWill list the commands but they are no good to you because, apart from the\r\ntrivial ones (like `version`), they need a keystore to operate on.\r\n\r\nThe `deploy` example can get us going.\r\n\r\nGenerally the first step in setting up a keystore is to set up all of the\r\nmaster passwords it will need for each of its sections in the environment\r\nusing your favourite random password generator. Your deployment app should\r\nprovide a template for this:\r\n\r\n````bash\r\ndeploy sample-script\r\n````\r\nwill in the current version (0.4.0.0) print this:\r\n\r\n````bash\r\nexport KEY_pw_top=pw_top;\r\nexport KEY_pw_signing=pw_signing;\r\nexport KEY_pw_eu_admin=pw_eu_admin;\r\nexport KEY_pw_eu_deploy=pw_eu_deploy;\r\nexport KEY_pw_eu_staging=pw_eu_staging;\r\nexport KEY_pw_us_admin=pw_us_admin;\r\nexport KEY_pw_us_deploy=pw_us_deploy;\r\nexport KEY_pw_us_staging=pw_us_staging;\r\nexport KEY_pw_dev=pw_dev;\r\n````\r\nHaving created the keystore you may want to clear down these definitions in\r\nwhich case it may be best to do this in a sub-shell.\r\n````bash\r\nbash\r\n# in the sub-shell eval the script to set up the variables with\r\n# just the sample values\r\neval $(deploy sample-script)\r\n# now we create the keystore, setting up the sections with the above passwords,\r\n# including the special 'signing' and 'top' sections\r\ndeploy intialise\r\n# keystore is set up but has not been signed; any attempt to use it will\r\n# result in an error (you can try skipping thisn step and see what happens)\r\ndeploy sign\r\n# the keystore has no useful deployment keys, so we can rotate in the initial\r\n# set by running the rotate script with no filter arguments; this example\r\n# just loads some stadard data for each key but in a real system random\r\n# keys would be generated or they would be laoded from a secure staging area,\r\n# depending upon the type of key\r\ndeploy rotate\r\ndeploy sign\r\n# the keystore is loaded: we can now list the keys\r\ndeploy ks list\r\n# this uses the generic 'ks' embedded in the 'deploy' app. We can also use\r\n# the 'ks' command directly.\r\nks --store deploy-keystore.json list\r\n# but now we have to tell it where to find our test keystore.\r\n# Note that every key has a 'T' listed immediately after the ':' indicating that\r\n# the secret text for the key is accessible. This is because the passwords for\r\n# all of the keys are still bound in the environment providing access to all\r\n# of the keys. We can inspect one of them:\r\ndeploy ks show-secret eu_admin_super_api_001\r\nWith all of the passwords present this looks just like a flat keystore. Let's\r\nclear down the passwords and exit the sub-shell.\r\nexit\r\n````\r\nNow if we try to show the secret again\r\n````bash\r\ndeploy ks show-secret eu_admin_super_api_001\r\n````\r\nWe get an error message complaining that the secret is not present.\r\n\r\nIf we list the keystore now we see the 'T' flags indicating that the\r\nsecret text for a key is accessible have all disappeared.\r\n\r\n````bash\r\ndeploy ks list\r\n````\r\n\r\nTo deploy a host we specify the host we use the `deploy` subcommand, specifying\r\nthe host that we want to deploy to.\r\n````bash\r\ndeploy deploy --help\r\n````\r\n\r\nWe can list the hosts to see what is available:\r\n````bash\r\ndeploy list-hosts\r\n````\r\n\r\nIn this context a 'deployment' will just make up a configuration file populated\r\nwith all the identifiers, hashes and secret keys that we need. (A real deployment\r\napp might upload the configuration file along with a package into a staging area\r\ntriggering a daemon to carry out the deployment.\r\n\r\nSupposing we choose to deploy to `live_eu`.\r\n\r\n````bash\r\ndeploy deploy live_eu\r\n````\r\nBut this won't work -- the deployment app can see none of the passwords it needs\r\nnad so reports an error on the first one it tries to load.\r\n\r\nWe need to set up the `live_eu` deployment password in our environment.\r\n````bash\r\nexport KEY_pw_eu_deploy=pw_eu_deploy;\r\n````\r\n\r\nNow if we list the key store we can see that just the keys we need have the\r\n'T' against then, including the keys in the `eu_deploy`, `eu_staging` and `dev`\r\nsections, but none of the keys in the `us_*` sections or the two passwords in\r\nthe `eu_admin` sections. The secrets from those sections are not needed for a\r\ndeployment, merely the hahses. (You will see other keys starting with, for example,\r\n`save_` and `pw_`: these are part of the devices to arrange the sections into\r\nthe intended hierarchy).\r\n\r\n````bash\r\ndeploy deploy live_eu\r\n````\r\n\r\nThis should now print out an apropriatly filled out JSON configuration file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}