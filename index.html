<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Keystore by cdornan</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Keystore</h1>
        <p>storing secret things</p>

        <p class="view"><a href="https://github.com/cdornan/keystore">View the Project on GitHub <small>cdornan/keystore</small></a></p>


        <ul>
          <li><a href="https://github.com/cdornan/keystore/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/cdornan/keystore/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/cdornan/keystore">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a name="keystore-storing-secret-things" class="anchor" href="#keystore-storing-secret-things"><span class="octicon octicon-link"></span></a>keystore: storing secret things</h1>

<p>Writing deployment scripts is a critical yet error-prone activity which we
would rather do in Haskell. One of the most difficult aspect of deployment
scripts is the management of credentials: they cannot be stored in the
VCS like almost everything else, but need to be organised and accessed
while under lock and key. This is the problem that keystore is trying to solve:
flexible, secure and well-typed deployment scripts.</p>

<ul>
<li><p>This module is written purely in Hakell and all of the cryptographic packages
it relies upon are written in Haskell.</p></li>
<li><p>It stores everything in a JSON format that has proven to be stable. We can can
use <a href="http://hackage.haskell.org/package/api-tools">migrations</a> &gt; in future
should the store need to be reorganized.</p></li>
<li>
<p>The underlying model is simple and flexible:</p>

<ul>
<li>
<em>Named keys</em>: every key has an name within the store that is associated
with some secret data. If the secret data for that key is to be stored then
it must identify another key in the store that will be used to encrypt the
data. (Some keys -- the passwords -- will typically be auto-loaded from
environment variables.)</li>
<li>
<em>Functional model</em>: keys can be deleted and added again but the design
encourages the retention of the history. The old keys remain available
but deployment scripts will naturally select the latest version of a key.
When a key is rotated this merely loads a new generation for the rotated
key.</li>
<li>
<em>Simple metadata</em>: oher information, such as the identity of the key
with its originating system (e.g., the identifier of an AWS IAM key)
and some arbitrary textual information (the 'comment') may be associated
with a key and accessible without recourse to the key or password needed
to access the secret information.</li>
<li>
<em>PKS</em>: the seret may be a RSA provate key with the public key stored
separately in the cler.</li>
<li>
<em>MFA</em>: a secret may be protected with multiple named keys, all of which
will be needed to recover the secret text.</li>
<li>
<em>Hashing</em>: all keys can be hashed with an appropriate PBKDF-2 function
and the hashes stored in the clear. These hashes may be sued to verify
passwords but also can be inserted directly into configuration files
for deployment. Precise control of the PBKDF-2 hash paramers is
avaiable.</li>
<li>
<em>Hierarchical organization</em>: keys can be stored in different sections
with each key being protected by a master key for that section. Sections
can be configured to store the master keys of other sections thereby
gaining acces to all of the keys in those sections and the keys they
have access to.</li>
<li>
<em>Systems integratio</em>: keys can automatically loaded from Environment
variables. Typically a keystore session will start by settingb up an
environment variable for the deployment section corresponding for
the node that you need to deploy to. This will provide access to
precisely the keys whose secrets you need to carry out the deployment
and no more. It only needs access to the hashes of admin keys then they
can be placed in separate higher-level <code>admin</code> sections. Provided care
is taken preparing the environment you will not deploy to the wrong host
(e.g., a live server rather than a staging server, or the wrong live
server) because those keys will not be accessible.</li>
<li>
<em>Configuration control</em>: the parameters controling the encryption and
hashing functions can be set up independently in each section of the
store, allowing for heavier hashing to be used on live servers and
light hashing to be used on development and staging servers where
authentication needs to be quick.</li>
<li>
<em>Keystore integrity</em>: the keystore can be signed and every operation
made to check that the keystore matches its signature (and the public
signing key matches an independent copy on the client).</li>
<li>
<em>External crypto operations</em>: keys in the keystore can be used to sign
or encrypt external obejcts (provided they can be loaded into memory).</li>
</ul>
</li>
<li>
<p>Perhaps apropriately, the keystore package has several layers. Most users
will probably need only the top "batteries-included" layer:</p>

<ul>
<li>
<code>Data.KeyStore.Sections</code>: this provides a high-level model that allows
a flexible hierarchical keystore to be set up relatively easily.
See the 'deploy' examplefor details.</li>
<li>
<code>Data.KeyStore.CLI</code> : This provides a stanalone program for inspecting
and editing your keystores. It can also be embedded into your own
deployment app. See the <code>deploy</code> example for details.</li>
<li>
<code>Data.KeyStore.IO</code>: this library provides general programatic access to
a keystore through <code>IO</code> primitives. See the source code for the <code>Sections</code>
for an example of this module in use.</li>
<li>
<code>Data.KeyStore.KS</code>: this library provides general programatic access to
a keystore through functional <code>KS</code> primitives. See the source code for
the <code>IO</code> for an exteded example this system in action.</li>
<li>
<code>Data.KeyStore.Types</code>: This provides access to keystores at the types
level.</li>
</ul>
</li>
</ul><h2>
<a name="05-migration-instructions" class="anchor" href="#05-migration-instructions"><span class="octicon octicon-link"></span></a>0.5 Migration instructions</h2>

<p>The formation of the names used in 'Data.Keystore.Sections' derived keystores
has changed to fix an issue (#3) that barred hosts, sections and key identifiers
from being prefixes of each other. See the changelog for details, especially
on how to ensure that an existing Sections-based keystore gets migrated properly.</p>

<h2>
<a name="launch-instructions" class="anchor" href="#launch-instructions"><span class="octicon octicon-link"></span></a>Launch Instructions</h2>

<p>Set yourself up with a ghc-7.6.3 or ghc-7.8.3 environment as appropriate.</p>

<div class="highlight highlight-bash"><pre>cabal install keystore
</pre></div>

<p>In addition to the keystore package library, this will establish in you cabal
bin directory the <code>ks</code> and <code>deploy</code> binaries. <code>ks</code> is the generic programme
for inspecting and editing keystores.</p>

<div class="highlight highlight-bash"><pre>ks --help
</pre></div>

<p>Will list the commands but they are no good to you because, apart from the
trivial ones (like <code>version</code>), they need a keystore to operate on.</p>

<p>The <code>deploy</code> example can get us going.</p>

<p>Generally the first step in setting up a keystore is to set up all of the
master passwords it will need for each of its sections in the environment
using your favourite random password generator. Your deployment app should
provide a template for this:</p>

<div class="highlight highlight-bash"><pre>deploy sample-script
</pre></div>

<p>will in the current version (0.4.0.0) print this:</p>

<div class="highlight highlight-bash"><pre><span class="nb">export </span><span class="nv">KEY_pw_top</span><span class="o">=</span>pw_top<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_signing</span><span class="o">=</span>pw_signing<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_eu_admin</span><span class="o">=</span>pw_eu_admin<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_eu_deploy</span><span class="o">=</span>pw_eu_deploy<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_eu_staging</span><span class="o">=</span>pw_eu_staging<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_us_admin</span><span class="o">=</span>pw_us_admin<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_us_deploy</span><span class="o">=</span>pw_us_deploy<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_us_staging</span><span class="o">=</span>pw_us_staging<span class="p">;</span>
<span class="nb">export </span><span class="nv">KEY_pw_dev</span><span class="o">=</span>pw_dev<span class="p">;</span>
</pre></div>

<p>Having created the keystore you may want to clear down these definitions in
which case it may be best to do this in a sub-shell.</p>

<div class="highlight highlight-bash"><pre>bash
<span class="c"># in the sub-shell eval the script to set up the variables with</span>
<span class="c"># just the sample values</span>
<span class="nb">eval</span> <span class="k">$(</span>deploy sample-script<span class="k">)</span>
<span class="c"># now we create the keystore, setting up the sections with the above passwords,</span>
<span class="c"># including the special 'signing' and 'top' sections</span>
deploy intialise
<span class="c"># keystore is set up but has not been signed; any attempt to use it will</span>
<span class="c"># result in an error (you can try skipping thisn step and see what happens)</span>
deploy sign
<span class="c"># the keystore has no useful deployment keys, so we can rotate in the initial</span>
<span class="c"># set by running the rotate script with no filter arguments; this example</span>
<span class="c"># just loads some stadard data for each key but in a real system random</span>
<span class="c"># keys would be generated or they would be laoded from a secure staging area,</span>
<span class="c"># depending upon the type of key</span>
deploy rotate
deploy sign
<span class="c"># the keystore is loaded: we can now list the keys</span>
deploy ks list
<span class="c"># this uses the generic 'ks' embedded in the 'deploy' app. We can also use</span>
<span class="c"># the 'ks' command directly.</span>
ks --store deploy-keystore.json list
<span class="c"># but now we have to tell it where to find our test keystore.</span>
<span class="c"># Note that every key has a 'T' listed immediately after the ':' indicating that</span>
<span class="c"># the secret text for the key is accessible. This is because the passwords for</span>
<span class="c"># all of the keys are still bound in the environment providing access to all</span>
<span class="c"># of the keys. We can inspect one of them:</span>
deploy ks show-secret eu_admin_super_api_001
With all of the passwords present this looks just like a flat keystore. Let<span class="err">'</span>s
clear down the passwords and <span class="nb">exit </span>the sub-shell.
<span class="nb">exit</span>
</pre></div>

<p>Now if we try to show the secret again</p>

<div class="highlight highlight-bash"><pre>deploy ks show-secret eu_admin_super_api_001
</pre></div>

<p>We get an error message complaining that the secret is not present.</p>

<p>If we list the keystore now we see the 'T' flags indicating that the
secret text for a key is accessible have all disappeared.</p>

<div class="highlight highlight-bash"><pre>deploy ks list
</pre></div>

<p>To deploy a host we specify the host we use the <code>deploy</code> subcommand, specifying
the host that we want to deploy to.</p>

<div class="highlight highlight-bash"><pre>deploy deploy --help
</pre></div>

<p>We can list the hosts to see what is available:</p>

<div class="highlight highlight-bash"><pre>deploy list-hosts
</pre></div>

<p>In this context a 'deployment' will just make up a configuration file populated
with all the identifiers, hashes and secret keys that we need. (A real deployment
app might upload the configuration file along with a package into a staging area
triggering a daemon to carry out the deployment.</p>

<p>Supposing we choose to deploy to <code>live_eu</code>.</p>

<div class="highlight highlight-bash"><pre>deploy deploy live_eu
</pre></div>

<p>But this won't work -- the deployment app can see none of the passwords it needs
nad so reports an error on the first one it tries to load.</p>

<p>We need to set up the <code>live_eu</code> deployment password in our environment.</p>

<div class="highlight highlight-bash"><pre><span class="nb">export </span><span class="nv">KEY_pw_eu_deploy</span><span class="o">=</span>pw_eu_deploy<span class="p">;</span>
</pre></div>

<p>Now if we list the key store we can see that just the keys we need have the
'T' against then, including the keys in the <code>eu_deploy</code>, <code>eu_staging</code> and <code>dev</code>
sections, but none of the keys in the <code>us_*</code> sections or the two passwords in
the <code>eu_admin</code> sections. The secrets from those sections are not needed for a
deployment, merely the hahses. (You will see other keys starting with, for example,
<code>save_</code> and <code>pw_</code>: these are part of the devices to arrange the sections into
the intended hierarchy).</p>

<div class="highlight highlight-bash"><pre>deploy deploy live_eu
</pre></div>

<p>This should now print out an apropriatly filled out JSON configuration file.</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/cdornan">cdornan</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>